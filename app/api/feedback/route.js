import { NextResponse } from "next/server";
import {
  createAuthenticatedSupabaseClient,
  getAuthenticatedUser,
} from "../../../libs/auth/server-auth.js";
import {
  analyzeFeedback,
  findDuplicateFeedback,
  groupSimilarFeedback,
} from "../../../libs/gpt.js";
import {
  withErrorHandler,
  createValidationError,
  createAuthError,
  createDatabaseError,
  createExternalServiceError,
  logErrorToMonitoring,
} from "../../../libs/errors/error-handler.js";
import {
  validateFeedback,
  validateRequired,
  validateUUID,
} from "../../../libs/validation/validators.js";


// Helper function to update feedback clusters automatically
async function updateFeedbackClusters(supabase, userId) {
  if (!process.env.OPENAI_API_KEY) {
    console.log("‚ö†Ô∏è OpenAI API key not configured - skipping clustering");
    return null;
  }

  if (!userId) {
    console.error("‚ùå User ID is required for clustering");
    return null;
  }

  try {
    // Get all feedback for this user
    const { data: feedbackData, error: fetchError } = await supabase
      .from("raw_feedback")
      .select("*")
      .eq("user_id", userId)
      .order("created_at", { ascending: false });

    if (fetchError) {
      console.error("‚ùå Failed to fetch feedback for clustering:", {
        error: fetchError.message,
        userId: userId,
        code: fetchError.code,
      });
      return null;
    }

    if (!feedbackData || feedbackData.length < 2) {
      console.log(
        `‚ÑπÔ∏è Not enough feedback for clustering (${
          feedbackData?.length || 0
        } items)`
      );
      return null;
    }

    // Transform feedback data with error handling
    const transformedFeedback = feedbackData
      .map((item) => {
        try {
          return {
            id: item.id,
            title: item.metadata?.title || "Untitled",
            content: item.content || "",
            source: item.platform || "unknown",
            priority: item.metadata?.priority || "medium",
            category: item.metadata?.category || "other",
            tags: Array.isArray(item.metadata?.tags) ? item.metadata.tags : [],
            aiAnalysis: item.ai_analysis || null,
          };
        } catch (transformError) {
          console.error("‚ùå Error transforming feedback item:", {
            itemId: item.id,
            error: transformError.message,
          });
          return null;
        }
      })
      .filter(Boolean); // Remove null items

    if (transformedFeedback.length < 2) {
      console.log("‚ÑπÔ∏è Not enough valid feedback after transformation");
      return null;
    }

    console.log(
      `üîó Updating feedback clusters for ${transformedFeedback.length} items...`
    );

    // Generate new clusters using AI with timeout
    const clusteringTimeout = new Promise((_, reject) => {
      setTimeout(
        () => reject(new Error("Clustering timeout after 30 seconds")),
        30000
      );
    });

    // Check if we already have valid clusters first
    console.log("üîç Checking for existing clusters for user:", userId);
    const { data: existingClusters, error: checkError } = await supabase
      .from("feedback_clusters")
      .select("*")
      .eq("user_id", userId)
      .order("created_at", { ascending: false });

    console.log("üîç Existing clusters check result:", {
      count: existingClusters?.length || 0,
      error: checkError?.message || null,
      clusters:
        existingClusters?.map((c) => ({
          id: c.id,
          theme: c.cluster_data?.theme,
        })) || [],
    });

    if (existingClusters && existingClusters.length > 0) {
      console.log(`‚úÖ Using existing ${existingClusters.length} clusters`);
      return {
        groups: existingClusters.map((cluster) => ({
          ...cluster.cluster_data,
          clusterId: cluster.id,
        })),
        summary: {
          totalGroups: existingClusters.length,
          largestGroupSize: Math.max(
            ...existingClusters.map((c) => c.feedback_ids?.length || 0)
          ),
          mostCommonTheme:
            existingClusters[0]?.cluster_data?.theme || "Unknown",
        },
        ungrouped: [],
        storedClusters: existingClusters,
      };
    }

    console.log("üîç No existing clusters found, generating new ones with AI");

    const feedbackGroups = await Promise.race([
      groupSimilarFeedback(transformedFeedback, userId),
      clusteringTimeout,
    ]);

    if (!feedbackGroups || !feedbackGroups.groups) {
      console.log("‚ÑπÔ∏è No clusters generated by AI");
      return null;
    }

    // Only create new clusters if none exist
    // DON'T delete existing clusters to preserve cluster_id relationships

    // Insert new clusters with validation using correct schema
    const clusterInserts = feedbackGroups.groups
      .filter((group) => group && group.theme) // Validate groups
      .map((group) => ({
        user_id: userId,
        cluster_data: group, // Store the full cluster data as JSONB
        feedback_ids: group.feedbackIds || [], // Array of feedback IDs
        total_feedback_count: transformedFeedback.length, // Total feedback count when clustering was generated
      }));

    if (clusterInserts.length > 0) {
      const { error: insertError } = await supabase
        .from("feedback_clusters")
        .insert(clusterInserts);

      if (insertError) {
        console.error("‚ùå Failed to insert new clusters:", {
          error: insertError.message,
          userId: userId,
          code: insertError.code,
          clusterCount: clusterInserts.length,
        });
        return null;
      }

      console.log(
        `‚úÖ Successfully updated ${clusterInserts.length} feedback clusters`
      );
    } else {
      console.log("‚ÑπÔ∏è No valid clusters to insert");
    }

    // Also try to retrieve existing clusters from database for UI
    const { data: storedClusters, error: retrieveError } = await supabase
      .from("feedback_clusters")
      .select("*")
      .eq("user_id", userId)
      .order("created_at", { ascending: false });

    if (retrieveError) {
      console.error("‚ùå Failed to retrieve stored clusters:", {
        error: retrieveError.message,
        userId: userId,
        code: retrieveError.code,
      });
    }

    // Return both the AI response and the stored clusters
    return {
      groups: (storedClusters || []).map((cluster) => ({
        ...cluster.cluster_data,
        clusterId: cluster.id,
      })),
      summary: feedbackGroups.summary,
      ungrouped: feedbackGroups.ungrouped,
      storedClusters: storedClusters || [],
    };
  } catch (error) {
    console.error("‚ùå Critical error in feedback clustering:", {
      error: error.message,
      stack: error.stack,
      userId: userId,
      timestamp: new Date().toISOString(),
    });

    // Try to log to a monitoring service if available
    if (process.env.MONITORING_ENDPOINT) {
      try {
        await fetch(process.env.MONITORING_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            level: "error",
            message: "Feedback clustering failed",
            error: error.message,
            userId: userId,
            timestamp: new Date().toISOString(),
          }),
        });
      } catch (monitoringError) {
        console.error(
          "Failed to send error to monitoring:",
          monitoringError.message
        );
      }
    }

    // Even if clustering fails, try to return existing clusters
    try {
      const { data: storedClusters } = await supabase
        .from("feedback_clusters")
        .select("*")
        .eq("user_id", userId)
        .order("created_at", { ascending: false });

      if (storedClusters && storedClusters.length > 0) {
        return {
          groups: storedClusters.map((cluster) => ({
            ...cluster.cluster_data,
            clusterId: cluster.id,
          })),
          storedClusters: storedClusters,
          summary: {
            totalGroups: storedClusters.length,
            largestGroupSize: Math.max(
              ...storedClusters.map((c) => c.feedback_ids?.length || 0)
            ),
            mostCommonTheme:
              storedClusters[0]?.cluster_data?.theme || "Unknown",
          },
        };
      }
    } catch (fallbackError) {
      console.error(
        "‚ùå Failed to retrieve fallback clusters:",
        fallbackError.message
      );
    }

    return null;
  }
}

// GET /api/feedback - Get all feedback for the authenticated user
export const GET = withErrorHandler(async (request) => {
  const supabase = createAuthenticatedSupabaseClient();
  const user = await getAuthenticatedUser();

  if (!user) {
    throw createAuthError();
  }

  // Fetch feedback from database
  const { data: feedbackData, error: fetchError } = await supabase
    .from("raw_feedback")
    .select("*")
    .eq("user_id", user.id)
    .order("created_at", { ascending: false });

  if (fetchError) {
    await logErrorToMonitoring(fetchError, "GET /api/feedback", user.id);
    throw createDatabaseError("Failed to fetch feedback", fetchError.message);
  }

    // Transform database data to match frontend format
    const transformedFeedback = feedbackData.map((item) => ({
      id: item.id,
      title: item.metadata?.title || "Untitled",
      content: item.content,
      source: item.platform || "unknown",
      priority: item.metadata?.priority || "medium",
      category: item.metadata?.category || "other",
      userEmail: item.metadata?.userEmail || null,
      tags: item.metadata?.tags || [],
      submittedAt: item.created_at,
      processed: item.processed,
      submittedBy: item.user_id,
      metadata: item.metadata,
      aiAnalysis: item.ai_analysis || null, // Include AI analysis if available
    }));

    // Get feedback clusters from database
    const feedbackGroups = await updateFeedbackClusters(supabase, user.id);

    // Calculate AI-powered statistics
    const aiStats = {
      totalAnalyzed: transformedFeedback.filter((f) => f.aiAnalysis).length,
      sentimentDistribution: transformedFeedback.reduce((acc, f) => {
        if (f.aiAnalysis?.sentiment) {
          acc[f.aiAnalysis.sentiment] = (acc[f.aiAnalysis.sentiment] || 0) + 1;
        }
        return acc;
      }, {}),
      aiPriorityDistribution: transformedFeedback.reduce((acc, f) => {
        if (f.aiAnalysis?.priority) {
          acc[f.aiAnalysis.priority] = (acc[f.aiAnalysis.priority] || 0) + 1;
        }
        return acc;
      }, {}),
      topThemes: feedbackGroups?.groups?.map((g) => g.theme) || [],
    };

  return NextResponse.json({
    success: true,
    data: transformedFeedback,
    feedbackGroups: feedbackGroups,
    aiStats: aiStats,
    message: "Feedback retrieved successfully",
  });
});

// POST /api/feedback - Create new feedback
export const POST = withErrorHandler(async (request) => {
  const supabase = createAuthenticatedSupabaseClient();
  const user = await getAuthenticatedUser();

  if (!user) {
    throw createAuthError();
  }

  const body = await request.json();

  // Debug log the received data
  console.log("Received feedback data:", body);

  // Validate and sanitize the data using centralized validation
  const sanitizedData = validateFeedback(body);

  // Process tags (already sanitized by validateFeedback)
  let processedTags = [];
  if (sanitizedData.tags) {
    if (Array.isArray(sanitizedData.tags)) {
      processedTags = sanitizedData.tags
        .filter((tag) => tag && typeof tag === "string")
        .map((tag) => tag.trim())
        .filter((tag) => tag);
    } else if (
      typeof sanitizedData.tags === "string" &&
      sanitizedData.tags.trim()
    ) {
      processedTags = sanitizedData.tags
        .split(",")
        .map((tag) => tag.trim())
        .filter((tag) => tag);
    }
  }

  let processedMetadata = null;
  if (sanitizedData.metadata) {
    if (typeof sanitizedData.metadata === "string") {
      try {
        processedMetadata = JSON.parse(sanitizedData.metadata);
      } catch (e) {
        throw createValidationError("Invalid JSON in metadata field");
      }
    } else {
      processedMetadata = sanitizedData.metadata;
    }
  }

  // Prepare data for database
  const feedbackData = {
    user_id: user.id,
    platform: sanitizedData.source,
    content: sanitizedData.content.trim(),
    metadata: {
      title: sanitizedData.title.trim(),
      priority: sanitizedData.priority,
      category: sanitizedData.category,
      userEmail: sanitizedData.userEmail || null,
      tags: processedTags,
      ...processedMetadata, // Include any additional metadata from the form
    },
    processed: false,
  };

  // Check for duplicate feedback before saving
  let duplicateCheck = null;
  if (process.env.OPENAI_API_KEY) {
    try {
      // Get existing feedback to check for duplicates
      const { data: existingFeedback } = await supabase
        .from("raw_feedback")
        .select("id, content")
        .eq("user_id", user.id)
        .limit(20); // Check against recent feedback only

      if (existingFeedback && existingFeedback.length > 0) {
        duplicateCheck = await findDuplicateFeedback(
          sanitizedData.content,
          existingFeedback,
          user.id
        );
      }
    } catch (error) {
      console.error("Warning: Duplicate check failed:", error.message);
      // Continue anyway
    }
  }

  // Save to database
  const { data: insertedData, error: insertError } = await supabase
    .from("raw_feedback")
    .insert([feedbackData])
    .select()
    .single();

  if (insertError) {
    await logErrorToMonitoring(insertError, "POST /api/feedback - database insert", user.id);
    throw createDatabaseError("Failed to create feedback", insertError.message);
  }

    // Update feedback clusters after adding new feedback
    await updateFeedbackClusters(supabase, user.id);

    // Perform AI Analysis on the feedback
    let aiAnalysis = null;
    if (process.env.OPENAI_API_KEY && insertedData.content) {
      console.log("üß† Performing AI analysis on feedback...");

      try {
        // Validate content before analysis
        if (!insertedData.content.trim()) {
          console.warn("‚ö†Ô∏è Empty content - skipping AI analysis");
        } else {
          // Create timeout for AI analysis
          const aiTimeout = new Promise((_, reject) => {
            setTimeout(
              () => reject(new Error("AI analysis timeout after 15 seconds")),
              15000
            );
          });

          // Analyze the feedback content with timeout
          aiAnalysis = await Promise.race([
            analyzeFeedback(insertedData.content, user.id),
            aiTimeout,
          ]);

          if (aiAnalysis) {
            console.log(
              `‚úÖ AI Analysis completed: ${aiAnalysis.sentiment} sentiment, ${aiAnalysis.priority} priority`
            );

            // Validate AI analysis structure
            if (!aiAnalysis.sentiment || !aiAnalysis.priority) {
              console.warn("‚ö†Ô∏è AI analysis incomplete - using fallback values");
              aiAnalysis = {
                sentiment: aiAnalysis.sentiment || "neutral",
                priority: aiAnalysis.priority || "medium",
                themes: aiAnalysis.themes || [],
                categories: aiAnalysis.categories || ["general"],
                summary: aiAnalysis.summary || "AI analysis completed",
                actionableInsights: aiAnalysis.actionableInsights || [],
                suggestedActions: aiAnalysis.suggestedActions || [],
                sentimentScore: aiAnalysis.sentimentScore || 0,
              };
            }

            // Update the feedback record with AI analysis
            try {
              const { error: updateError } = await supabase
                .from("raw_feedback")
                .update({
                  ai_analysis: aiAnalysis,
                })
                .eq("id", insertedData.id);

              if (updateError) {
                console.error(
                  "‚ùå Failed to update feedback with AI analysis:",
                  {
                    error: updateError.message,
                    feedbackId: insertedData.id,
                    code: updateError.code,
                  }
                );
                // Continue anyway - we still have the analysis for the response
              }
            } catch (updateError) {
              console.error(
                "‚ùå Critical error updating feedback with AI analysis:",
                {
                  error: updateError.message,
                  feedbackId: insertedData.id,
                  stack: updateError.stack,
                }
              );
              // Continue anyway
            }
          } else {
            console.warn("‚ö†Ô∏è AI analysis returned empty result");
          }
        }
      } catch (aiError) {
        console.error("‚ùå AI analysis failed:", {
          error: aiError.message,
          feedbackId: insertedData.id,
          contentLength: insertedData.content?.length || 0,
          stack: aiError.stack,
        });

        // Try to log to monitoring service
        if (process.env.MONITORING_ENDPOINT) {
          try {
            await fetch(process.env.MONITORING_ENDPOINT, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                level: "error",
                message: "AI analysis failed",
                error: aiError.message,
                feedbackId: insertedData.id,
                userId: user.id,
                timestamp: new Date().toISOString(),
              }),
            });
          } catch (monitoringError) {
            console.error(
              "Failed to send AI error to monitoring:",
              monitoringError.message
            );
          }
        }

        // Continue anyway - feedback was saved successfully, just without AI analysis
      }
    } else {
      if (!process.env.OPENAI_API_KEY) {
        console.log("‚ÑπÔ∏è OpenAI API key not configured - skipping AI analysis");
      } else if (!insertedData.content) {
        console.warn("‚ö†Ô∏è No content provided - skipping AI analysis");
      }
    }

    // Transform the response to match frontend format
    const responseData = {
      id: insertedData.id,
      title: insertedData.metadata?.title || "Untitled",
      content: insertedData.content,
      source: insertedData.platform,
      priority: insertedData.metadata?.priority || "medium",
      category: insertedData.metadata?.category || "other",
      userEmail: insertedData.metadata?.userEmail || null,
      tags: insertedData.metadata?.tags || [],
      submittedAt: insertedData.created_at,
      processed: insertedData.processed,
      submittedBy: insertedData.user_id,
      metadata: insertedData.metadata,
      aiAnalysis: aiAnalysis, // Include AI analysis in response
      duplicateCheck: duplicateCheck, // Include duplicate check results
    };

    const response = {
      success: true,
      data: responseData,
      message: "Feedback created successfully",
    };

    // Add AI analysis status to response
    if (aiAnalysis) {
      response.message = "Feedback created and analyzed successfully";
      response.aiAnalysisStatus = "completed";
    } else if (process.env.OPENAI_API_KEY) {
      response.aiAnalysisStatus = "failed";
    } else {
      response.aiAnalysisStatus = "disabled";
    }

    // Add duplicate warning if needed
    if (duplicateCheck?.isDuplicate && duplicateCheck.similarityScore > 0.7) {
      response.duplicateWarning = {
        message: "Similar feedback already exists",
        similarityScore: duplicateCheck.similarityScore,
        explanation: duplicateCheck.explanation,
        suggestedAction: duplicateCheck.suggestedAction,
      };
    }

  return NextResponse.json(response, { status: 201 });
});

// PUT /api/feedback - Update existing feedback
export const PUT = withErrorHandler(async (request) => {
  const supabase = createAuthenticatedSupabaseClient();
  const user = await getAuthenticatedUser();

  if (!user) {
    throw createAuthError();
  }

  const body = await request.json();

  validateRequired(body, ["id"]);
  validateUUID(body.id, "Feedback ID");

    // Prepare update data
    const updateData = {};

    // Handle processed status update
    if (typeof body.processed === "boolean") {
      updateData.processed = body.processed;
    }

    // Handle metadata updates
    if (body.metadata) {
      updateData.metadata = body.metadata;
    }

    // Update the feedback in database
    const { data: updatedData, error: updateError } = await supabase
      .from("raw_feedback")
      .update(updateData)
      .eq("id", body.id)
      .eq("user_id", user.id) // Ensure user can only update their own feedback
      .select()
      .single();

  if (updateError) {
    await logErrorToMonitoring(updateError, "PUT /api/feedback", user.id);
    throw createDatabaseError("Failed to update feedback", updateError.message);
  }

  if (!updatedData) {
    throw createValidationError("Feedback not found or unauthorized");
  }

    // Update feedback clusters after feedback was updated
    await updateFeedbackClusters(supabase, user.id);

    // Transform the response to match frontend format
    const responseData = {
      id: updatedData.id,
      title: updatedData.metadata?.title || "Untitled",
      content: updatedData.content,
      source: updatedData.platform,
      priority: updatedData.metadata?.priority || "medium",
      category: updatedData.metadata?.category || "other",
      userEmail: updatedData.metadata?.userEmail || null,
      tags: updatedData.metadata?.tags || [],
      submittedAt: updatedData.created_at,
      processed: updatedData.processed,
      submittedBy: updatedData.user_id,
      metadata: updatedData.metadata,
    };

  return NextResponse.json({
    success: true,
    data: responseData,
    message: "Feedback updated successfully",
  });
});

// DELETE /api/feedback - Delete feedback
export const DELETE = withErrorHandler(async (request) => {
  const supabase = createAuthenticatedSupabaseClient();
  const user = await getAuthenticatedUser();

  if (!user) {
    throw createAuthError();
  }

  const url = new URL(request.url);
  const feedbackId = url.searchParams.get("id");

  if (!feedbackId) {
    throw createValidationError("Feedback ID is required");
  }

  validateUUID(feedbackId, "Feedback ID");

    // Delete the feedback from database
    const { error: deleteError } = await supabase
      .from("raw_feedback")
      .delete()
      .eq("id", feedbackId)
      .eq("user_id", user.id); // Ensure user can only delete their own feedback

  if (deleteError) {
    await logErrorToMonitoring(deleteError, "DELETE /api/feedback", user.id);
    throw createDatabaseError("Failed to delete feedback", deleteError.message);
  }

  // Update feedback clusters after feedback was deleted
  await updateFeedbackClusters(supabase, user.id);

  return NextResponse.json({
    success: true,
    message: "Feedback deleted successfully",
  });
});
